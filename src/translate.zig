const std = @import("std");
const builtin = @import("builtin");

const Ast = @import("Ast.zig");
const proto = @import("proto.zig");

pub fn main() !void {
    var gpa: std.heap.GeneralPurposeAllocator(.{}) = .{};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var args = try std.process.argsWithAllocator(allocator);
    defer args.deinit();
    _ = args.skip();

    var maybe_input_file: ?[]const u8 = null;
    var maybe_output_file: ?[]const u8 = null;

    while (args.next()) |arg| {
        if (maybe_input_file == null) {
            maybe_input_file = arg;
            continue;
        }
        if (maybe_output_file == null) {
            maybe_output_file = arg;
            continue;
        }
        fail("too many arguments", .{});
    }
    const input_file_path = maybe_input_file orelse fail("expected input file", .{});

    const input = try std.fs.cwd().openFile(input_file_path, .{});
    defer input.close();

    const source = try input.readToEndAllocOptions(
        gpa,
        1024 * 1024,
        null,
        @alignOf(u8),
        0,
    );
    defer allocator.free(source);

    var ast = try Ast.parse(allocator, source);
    defer ast.deinit(allocator);

    if (ast.errors.len != 0) {
        const stderr = std.io.getStdErr();
        for (ast.errors) |err| {
            try err.render(ast, stderr.writer());
        }
        fail("failed with {d} error(s)", .{ast.errors.len});
    }

    const file = if (maybe_output_file) |output_path|
        try std.fs.cwd().createFile(output_path, .{})
    else
        std.io.getStdOut();
    defer file.close();

    const stream = file.writer();
    try Writer.printAst(ast, allocator, stream);
}

fn fail(comptime fmt: []const u8, args: anytype) noreturn {
    const stderr = std.io.getStdErr().writer();
    stderr.print(fmt ++ "\n", args) catch @panic("failed to print the stderr");
    std.posix.abort();
}

const Writer = struct {
    ident: usize = 0,
    gpa: std.mem.Allocator,
    ast: Ast,

    fn printAst(ast: Ast, gpa: std.mem.Allocator, stream: anytype) !void {
        var w: Writer = .{
            .ast = ast,
            .gpa = gpa,
        };

        try stream.writeAll(
            \\// File generated by ZPB
            \\const std = @import("std");
            \\const zpb = @import("zpb");
            \\
            \\const Info = zpb.Info;
            \\const Mixin = zpb.MessageMixin; 
            \\
            \\
        );

        const roots = ast.spanToList(.root);
        for (roots) |member| {
            try stream.writeByteNTimes(' ', w.ident);
            const tag = ast.nodes.items(.tag)[@intFromEnum(member)];
            switch (tag) {
                .message => try w.printMessage(member, stream),
                else => std.debug.print("TODO: translate {s}\n", .{@tagName(tag)}),
            }
        }
    }

    fn printMessage(w: *Writer, node_idx: Ast.Node.Index, stream: anytype) !void {
        const ast = w.ast;
        const tags = ast.nodes.items(.tag);
        const main_tokens = ast.nodes.items(.main_token);
        const datas = ast.nodes.items(.data);

        const ident_token = main_tokens[@intFromEnum(node_idx)].unwrap().?;
        const message_ident = ast.identifier(ident_token);
        const members = ast.spanToList(node_idx);

        // Relates the field_name token to the field_number token.
        var field_numbers: std.AutoArrayHashMapUnmanaged(
            Ast.Node.Data.Field,
            void,
        ) = .{};
        defer field_numbers.deinit(w.gpa);

        try w.print(stream, "pub const {s} = struct {{\n", .{message_ident});
        w.ident += 4;
        for (members) |member| {
            const tag = tags[@intFromEnum(member)];
            switch (tag) {
                .field => {
                    const field_data = datas[@intFromEnum(member)].field;
                    try field_numbers.put(w.gpa, field_data, {});
                    const field_ident = ast.identifier(field_data.field_name);
                    try w.print(stream, "{s}: ", .{field_ident});
                    try printType(field_data.type, stream);
                    try stream.writeAll(",\n");
                },
                else => std.debug.print("TODO: printMessage {s}", .{@tagName(tag)}),
            }
        }

        try w.writeAll(stream, "pub const __info: Info(@This()) = .{\n");

        w.ident += 4;
        var number_iterator = field_numbers.iterator();
        while (number_iterator.next()) |entry| {
            const field = entry.key_ptr.*;
            const ident = ast.identifier(field.field_name);
            const number = try std.fmt.parseInt(
                u32,
                ast.identifier(field.field_number),
                10,
            );
            try w.print(
                stream,
                ".{} = .{{ .field_number = {d}, .field_type = .{s} }},\n",
                .{ std.zig.fmtId(ident), number, @tagName(field.type) },
            );
        }
        w.ident -= 4;
        try w.writeAll(stream, "};\n");

        try w.writeMultiLine(stream,
            \\
            \\/// Encodes the message struct into bytes.
            \\pub fn encode(self: *const @This(), allocator: std.mem.Allocator) ![]const u8 {
            \\    return Mixin(@This()).encode(self, allocator);
            \\}
            \\
            \\/// Decodes bytes into the message struct.
            \\pub fn decode(bytes: []const u8) !@This() {
            \\    return Mixin(@This()).decode(bytes);
            \\}
        );

        w.ident -= 4;

        try w.writeAll(stream, "\n};\n\n");
    }

    fn printType(ty: proto.Type, stream: anytype) !void {
        const name = switch (ty) {
            .uint32 => "u32",
            .bytes => "[]const u8",
        };
        try stream.writeAll(name);
    }

    fn writeAll(
        w: *Writer,
        stream: anytype,
        bytes: []const u8,
    ) !void {
        try stream.writeByteNTimes(' ', w.ident);
        try stream.writeAll(bytes);
    }

    fn writeMultiLine(
        w: *Writer,
        stream: anytype,
        bytes: []const u8,
    ) !void {
        var lines = std.mem.splitScalar(u8, bytes, '\n');
        while (lines.next()) |line| {
            try w.writeAll(stream, line);
            if (lines.index == null) break;
            try stream.writeByte('\n');
        }
    }

    fn print(
        w: *Writer,
        stream: anytype,
        comptime fmt: []const u8,
        args: anytype,
    ) !void {
        try stream.writeByteNTimes(' ', w.ident);
        try stream.print(fmt, args);
    }
};
